#pragma config(Sensor, in1,    MobilePotL,     sensorPotentiometer)
#pragma config(Sensor, in2,    MobilePotR,     sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in6,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, EncLeft,        sensorQuadEncoder)
#pragma config(Motor,  port1,           Left2,         tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port3,           MobileGoalL,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           MobileGoalR,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          Right2,        tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl9)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int MoptimalL;
int MoptimalR;
int CoptimalL;
int CoptimalR;



task PID_ClawLift()
{
	float ckp = 0.24; //tune
	float cki = 0.001; //tune
	float ckd = 0.28; //tune

	float ccurrentL ;
	float cerrorTl;
	float clastErrorL = 0;
	float cproportionL;
	float cintegralL;
	float cderivativeL;
	float ccurrentR ;
	float cerrorTr;
	float clastErrorR = 0;
	float cproportionR;
	float cintegralR;
	float cderivativeR;

	while(true){


		float cerrorL = CoptimalL - SensorValue[ClawArmPotL];
		float cerrorR = CoptimalR - SensorValue[ClawArmPotR];



		if (abs(cerrorL) < 200 && cerrorL !=0)
		{
			cerrorTl = cerrorL;
		}
		else{
			cerrorTl = 0;
		}

		if (abs(cerrorR) < 200 &&cerrorR !=0)
		{
			cerrorTr = cerrorR;
		}
		else{
			cerrorTr = 0;
		}

		if (abs(cerrorTl)> 50 / cki){
			cerrorTl = 50 / cki;
		}

		if (cerrorL ==0){
			cderivativeL = 0;
		}

		if (abs(cerrorTr)> 50 / cki){
			cerrorTr = 50 / cki;
		}

		if (cerrorR ==0){
			cderivativeR = 0;
		}




		cproportionL = cerrorL * ckp;
		cproportionR = cerrorR * ckp;
		cintegralL = cerrorTl  * cki;
		cintegralR = cerrorTr  * cki;
		cderivativeL = (cerrorL - clastErrorL) * ckd;
		cderivativeR = (cerrorR - clastErrorR) * ckd;

		clastErrorL = cerrorL;
		clastErrorR = cerrorR;

		ccurrentL = cproportionL + cintegralL + cderivativeL;
		ccurrentR = cproportionR + cintegralR + cderivativeR;

		motor[ClawArmR] = -ccurrentR;
		motor[ClawArmL] = -ccurrentL;



		wait1Msec(40);

	}
	return;

}


task PID_MG()
{
float mkp = 0.3; //tune
float mki = 0.00001; //tune
float mkd = 0.2; //tune

float mcurrentL ;
float merrorTl;
float mlastErrorL = 0;
float mproportionL;
float mintegralL;
float mderivativeL;
float mcurrentR ;
float merrorTr;
float mlastErrorR = 0;
float mproportionR;
float mintegralR;
float mderivativeR;

while(true){


float merrorL = (MoptimalL - SensorValue[MobilePotL]);
float merrorR = (MoptimalR - SensorValue[MobilePotR]);



if (abs(merrorL) < 200 && merrorL !=0)
{
merrorTl = merrorL;
}
else{
merrorTl = 0;
}

if (abs(merrorR) < 200 && merrorR !=0)
{
merrorTr = merrorR;
}
else{
merrorTr = 0;
}

if (abs(merrorTl)> 50 / mki){
merrorTl = 50 / mki;
}

if (merrorL ==0){
mderivativeL = 0;
}

if (abs(merrorTr)> 50 / mki){
merrorTr = 50 / mki;
}

if (merrorR ==0){
mderivativeR = 0;
}




mproportionL = merrorL * mkp;
mproportionR = merrorR * mkp;
mintegralL = merrorTl  * mki;
mintegralR = merrorTr  * mki;
mderivativeL = (merrorL - mlastErrorL) * mkd;
mderivativeR = (merrorR - mlastErrorR) * mkd;

mlastErrorL = merrorL;
mlastErrorR = merrorR;

mcurrentL = mproportionL + mintegralL + mderivativeL;
mcurrentR = mproportionR + mintegralR + mderivativeR;

motor[MobileGoalR] = mcurrentR;
motor[MobileGoalL] = mcurrentL;



wait1Msec(40);

}
return;
}

task main()
{


	MoptimalL = SensorValue [MobilePotL];
	MoptimalR = SensorValue [MobilePotR];
	CoptimalL = SensorValue [ClawArmPotL];
	CoptimalR = SensorValue [ClawArmPotR];
	startTask (PID_MG);
	startTask (PID_ClawLift);




	while (true){


		if(vexRT[Btn5U] == 1)
		{
			while((vexRT[Btn5U] ==1)&&(SensorValue[ArmPotL]<2225)&&(SensorValue[ArmPotL] != 248)) {
				motor [TL] = motor [TR] = 120;

				wait1Msec (40);

			}
		}
		else if(vexRT[Btn5D] == 1)
		{
			while(vexRT[Btn5D] ==1) {
				motor [TL] = motor [TR] = -120;

				wait1Msec (40);

			}
		}

		else {
			motor [TL] = motor [TR] = 0;
		}



				motor [TR]= motor [TL]= vexRT[Ch3Xmtr2];

		if ((vexRT [Btn6U] ==1)||(vexRT [Btn6UXmtr2] ==1)) {
			CoptimalL = 992;
			CoptimalR = 1069;

		}

		else if ((vexRT [Btn6D] ==1)||(vexRT [Btn6DXmtr2] ==1)){

			CoptimalL = 2430;
			CoptimalR = 2650;

		}
		else {


		}


		if ((vexRT [Btn8D] ==1)||(vexRT [Btn5DXmtr2] ==1)) {

		MoptimalL = 1439;
		MoptimalR = 1322;
		}

		else if ((vexRT [Btn8U] ==1)||(vexRT [Btn5UXmtr2] ==1)) {
		MoptimalL = 4020;
		MoptimalR = 3822;
		}
		else {
		MoptimalL = SensorValue[MobilePotL];
		MoptimalR = SensorValue[MobilePotR];
		}


		//---------------------------------------------------------------------------------------------------------------

		float ch3_drive;
		float ch1_drive;
		float a = vexRT[Ch3] / 127.0;
		float b = vexRT[Ch1] / 127.0;
		ch3_drive = (0.463* (pow(a,3))- (0.069 * pow(a,2)) + (0.614 * a) ) * 127;
		ch1_drive = (0.463* (pow(b,3))- (0.069 * pow(b,2)) + (0.614 * b) ) * 127;


		motor[Left1]  = ((ch3_drive) + (ch1_drive));
		motor[Left2]  = ((ch3_drive) + (ch1_drive));
		motor[Right1] = ((ch3_drive) - (ch1_drive));
		motor[Right2] = ((ch3_drive) - (ch1_drive));


		wait1Msec(40);
	}
}
